---
title: "Lecture 14 - Theory and Task for Homework"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook

### Lecture 14 - Using inputs in the ShinyApp

#### Basic idea of using inputs

The overall idea of using `inputs` from the User Interface is to define them first in ui.R file as `inputId` objects and use them in server.R file as `input$inputId` for example:

```r

# Defined in the ui.R:
dateInput(inputId = "DateStart", label = "Insert Start Date", value = "2017-01-01")

# Used in server.R as:
  # create reactive object 
  StartDate <- reactive( {as.POSIXct(input$DateStart)} ) 
  # or simply
  input$DateStart

```

in case of creation of reactive objects we can re-use them by adding `()` to the object name, for example: 

```r
# using reactive value further in the code 
 filter(StartDateTime > StartDate(), StartDateTime < EndDate())
```

#### Modularise your code

You can create reactive objects using `reactive` function. Advantage is that:

* you can perform data manipulation inside this reactive function
* result of manipulation will be kept in the memory
* you can modularise your code by reusing obtained result several times later in your code

For example, we perform complex manipulations and filtering as follows:

```r
# Creating reactive object inside reactive function
    # save as data frame data used for statistics in other render functions
  DF_SUM <- reactive({
    
    DF_TEMP %>% 
      # filters for categories
      filter(EventText == input$selInput) %>% 
      # group by 
      group_by(Name) %>% 
      # filters X date
      filter(StartDateTime > StartDate(), StartDateTime < EndDate())
  })

# Object DF_SUM() can be accessed later in the script...

  output$Plot2 <- renderPlot({
    # generate object for the plot using DF_SUM
    DF_SUM() %>% 
      ggplot(aes(x = StartDateTime, y = TimeTotal, col = EventText)) + geom_boxplot() +
      facet_wrap(Name ~ EventText) +
      ggtitle(paste("Overview of Steps ", "from: ",
                                      StartDate(), " to: ", EndDate(), sep = "")) 
```

#### Debugging / develop your code modules

Once creating your `server.R` script you will inevitably need to try our what you will get. My personal hint is to try pieces of code using pre-defined `dummy` variables that you can comment inside your code. For example:

```r
# Un comment this code for debugging...
  # uncomment for debugging...
  StartDate <- "2017-04-20 00:10:20"
  EndDate <- "2017-08-20 00:10:20"

# ... and temporary remove brackets
 DF_SUM %>% 
      ggplot(aes(x = StartDateTime, y = TimeTotal, col = EventText)) + geom_boxplot() +
      facet_wrap(Name ~ EventText) +
      ggtitle(paste("Overview of Steps ", "from: ",
                                      StartDate, " to: ", EndDate, sep = "")) 
```
Then you can execute this code by pressing **CTRL + Enter** or **CMD + Enter** on Mac and verify the result in the Environment or as a Plot output result...

### Using buttons to delay reactions

In some cases you will want to avoid using reactivity concept immediately. It may be relevant to only update **outputs** only after specific confirmation. To create this interaction flavour of ShinyApp you will need to define the actionButton and then use this object in your server.R script using observeEvent function. For example:

```{r}
# in ui.R: Generate actionButton with inputId = "updateGraph"
actionButton(inputId = "updateGraph", label = "Update Graphs")

# in server.R: create snippet module with eventReactive(input$inputId{ code })
 delayReaction <- eventReactive(input$updateGraph, {
   
     # place the code here that will be run when button is clicked
    DF_SUM() %>% 
        ggplot(aes(x = StartDateTime, y = TimeTotal, col = EventText)) + 
        geom_smooth(alpha = 0.5, se = StatErr()) +
        facet_wrap(~Name) + ylab("Duration of Step, seconds") +
        ggtitle(paste("Overview of Steps ", "from: ",
                                        StartDate(), " to: ", EndDate(), sep = "")) 
  })

  # finally create the output using delayReaction() object!
  output$Plot1 <- renderPlot({   delayReaction() })
 
```


### Some ideas for practical work

#### Debug your code in Shiny server.R file

Snippet of code below was taken directly from the server.R script. 

```{r}
############# Run this code to create object DF_TEMP

# data frame containing information from multiple sensors
DF_Data <- read_csv("DF_Data.csv")
# data frame containing equipment information
DF_Equipm <- read_csv("DF_EquipmData.csv")
# data frame containing Event Names
DF_EvCode <- read_csv("DF_EvCodeData.csv")

# Data manipulation and saving to the DF_TEMP
DF_TEMP <- DF_Data %>% 
  # arrange by date 
  arrange(StartDateTime) %>% 
  # join to decode equipment serial number
  inner_join(DF_Equipm, by = "IDEquipment") %>% 
  # select only column needed
  select(StartDateTime, Name, EventCode, TimeTotal) %>% 
  # join to decode Event Code meaning
  inner_join(DF_EvCode, by = "EventCode") %>% 
  # select only column needed
  select(StartDateTime, Name, EventCode, TimeTotal, EventText)
#############

 # # uncomment below code for debugging...
  # StartDate <- "2017-04-20 00:10:20"
  # EndDate <- "2017-08-20 00:10:20"
  # StatErr <- FALSE

############ Modify this code below to be able to run the code inside

 DF_SUM <- reactive({
    
    DF_TEMP %>% 
      # filters for categories
      filter(EventText == input$selInput) %>% 
      # group by 
      group_by(Name) %>% 
      # filters X date
      filter(StartDateTime > StartDate(), StartDateTime < EndDate())
  })
```

#### use buttons in your ShinyApp

This practical excercise will allow you to practice skills to create action button with `inputId = "updateGraph"` as well as to execute code in Shiny only after this button was pressed

Try to add new `button` to the right of the `selectInput` field... ![alt text][id]



[id]: task/t1.png "Title"



```{r, eval=FALSE, include=FALSE}
# create new action button in ui.R
column(1, actionButton(inputId = "updateGraph", label = "Update Point Plot"))
```

... make sure that the `Plot-Points` is only updated once user pressing the new button?

Hint: use `delayed <- eventReactive(input$<inputId>, { code })`

```{r, eval=FALSE, include=FALSE}
  ## creating eventReactive using new button
  updateGraph <- eventReactive(input$updateGraph,
    {
      DF_SUM()  %>% 
            ggplot(aes(x = StartDateTime, y = TimeTotal, col = EventText)) + geom_point()+
            geom_smooth(alpha = 0.5, se = StatErr()) +
            facet_wrap(~Name) +
            ylab("Duration of Step, seconds") +
            ggtitle(paste("Overview of Steps ", "from: ",
                                            StartDate(), " to: ", EndDate(), sep = ""))
      
    })
```

Hint: use `delayed()` object when creating `output$'object'`

```{r, eval=FALSE, include=FALSE}
 ## make a plot
  output$Plot1 <- renderPlot({ updateGraph() })
```

